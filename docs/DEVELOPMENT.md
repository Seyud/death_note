# 🚀 开发文档

## 📋 项目概述

🔧 **Death Note** 是一个基于《死亡笔记》动漫的系统工具，以死神琉克(Ryuk)和死亡笔记系统为核心概念，实现了多平台用户身份识别、黑名单管理和决策制导功能。项目采用完全异步架构，专注于Android平台的数据提取和分析，使用Tokio异步运行时实现高并发性能。

## 🏗️ 项目架构

### 🔑 核心概念

基于《死亡笔记》的核心设定：
- **死亡笔记** → 黑名单系统：记录应被审判的灵魂名单，实现目标检查和记录功能
- **死神之眼** → 识别系统：能够看透人类真名和剩余寿命的特殊视觉，并行识别多平台用户
- **琉克** → 制导系统：因厌倦死神界而将死亡笔记丢弃至人间的观察者，智能决策和异步审判

### 🎯 核心模块

#### 1. 👁️‍🗨️ **死神之眼系统** (`identification` module) 
**异步并行身份识别模块**

- **📱 CoolapkShinigamiEye** (`coolapk_identifier.rs`) - 异步酷安用户识别
- **✈️ TelegramShinigamiEye** (`telegram_identifier.rs`) - 异步Telegram用户识别
- **💬 QQShinigamiEye** (`qq_identifier.rs`) - 异步QQ用户识别
- **👁️‍🗨️ ShinigamiEyeManager** (`manager.rs`) - 统一协调所有识别器，支持超时控制和并发执行
- **📅 LifespanCalculator** (`lifespan_calculator.rs`) - 寿命计算器，基于用户ID和黑名单状态计算寿命
- **🔧 ShinigamiEye Traits** (`traits.rs`) - 定义识别器通用接口和结果抽象

#### 2. 📖 **死亡笔记系统** (`blacklist` module)
**黑名单管理和审判记录**

- **📖 DeathNote** (`manager.rs`) - 主要黑名单管理器，提供各平台目标检查和记录功能
- **📖 CoolapkBlacklist** (`coolapk.rs`) - 酷安平台黑名单数据（支持配置化管理）
- **📖 QQBlacklist** (`qq.rs`) - QQ平台黑名单数据（支持配置化管理）
- **📖 TelegramBlacklist** (`telegram.rs`) - Telegram平台黑名单数据（支持配置化管理）
- **⚙️ 配置管理系统** - 基于 `build.rs` + TOML 的编译时配置嵌入机制

#### 3. 😈 **琉克制导系统** (`guidance` module)
**基于异步识别结果的智能决策系统**

- **🧠 RyukGuidanceSystem** (`guidance_async.rs`) - 模拟琉克性格的智能决策，包含苹果机制和厌倦值
- **🍎 苹果系统** - 基于发现目标数量的动态苹果消费机制
- **⚰️ AndroidPartitionOperator** (`partition_ops.rs`) - Android分区操作器，实现灵魂收割的底层操作
- **⚰️ 异步灵魂收割** - 模拟666ms延迟的异步收割仪式，支持并行处理多个目标

#### 4. ☁️ **云控系统** (`cloud_control` module)
**动态云端黑名单管理系统**

- **☁️ CloudControlManager** (`manager.rs`) - 云控核心管理器，协调客户端和缓存，提供统一的云控数据访问接口
- **🌐 CloudControlClient** (`client.rs`) - 网络客户端，负责从远程仓库获取黑名单数据
- **📂 CloudControlCache** (`cache.rs`) - 本地缓存系统，提供离线数据支持和性能优化
- **⚙️ 编译时配置嵌入** (`embedded_config.rs`) - 将云控配置在构建时嵌入到二进制文件中
- **📊 类型定义系统** (`types.rs`) - 定义平台枚举、配置结构和数据模型
- **🔀 数据分离机制** - 云控名单与本地编译名单完全分离，确保互不干扰

## 🔄 程序运行顺序

### 🚀 异步执行流程

```
📓 死亡笔记系统启动 (Tokio异步运行时)
    ↓
😈 Ryuk: 终于有点有趣的事情了...
    ↓
☁️ 初始化云控系统 (CloudControlManager)
    ├── 📄 从编译时嵌入配置加载云控设置
    ├── � 创建网络客户端 (CloudControlClient)
    ├── 📂 初始化本地缓存系统 (CloudControlCache)
    ├── 🔄 优先从缓存加载数据 (减少网络请求)
    ├── 📡 缓存无效时从远程仓库获取数据
    ├── 🔀 确保云控名单与本地名单数据分离
    └── ✅ 显示云控系统状态和统计信息
    ↓ 
🎯 创建死神之眼管理器 (ShinigamiEyeManager)
    ├── 📱 注册酷安死神之眼识别器
    ├── 💬 注册QQ死神之眼识别器  
    ├── ✈️ 注册Telegram死神之眼识别器
    └── ⏰ 设置6秒死神之眼持续时间限制
    ↓
😈 创建琉克制导系统 (RyukGuidanceSystem)
    ├── 🔍 检测Android设备环境
    ├── 🍎 初始化苹果计数器 (0个)
    ├── 😴 设置初始厌倦值 (100)
    └── 📖 关联死亡笔记实例
    ↓
👁️‍🗨️ 并行激活所有死神之眼 (activate_all)
    ├── 📱 酷安死神之眼 (异步扫描)
    │   ├── 🔍 扫描 
    │   ├── 🧪 扫描  (调试模式)
    │   └── 👤 提取用户UID并计算寿命
    ├── 💬 QQ死神之眼 (异步扫描)
    │   ├── 🔍 扫描 
    │   ├── 🧪 扫描  (调试模式)
    │   └── 👤 提取QQ号并计算寿命
    ├── ✈️ Telegram死神之眼 (异步扫描)
    │   ├── 🔍 扫描 
    │   ├── 🧪 扫描  (调试模式)
    │   └── 👤 提取用户ID并计算寿命
    └── ⏰ 所有识别器并发执行，6秒超时控制
    ↓
📊 收集并显示死神之眼观察结果
    ├── 📈 统计各平台发现的目标数量
    ├── 👤 显示每个目标的详细信息 (名称/寿命/黑名单状态)
    └── 📋 汇总总计发现的目标数
    ↓
☁️ 应用云控黑名单检查 (apply_cloud_blacklist)
    ├── 🔀 对每个识别结果进行云控名单检查 (本地+云控)
    ├── 📊 收集所有黑名单目标信息 (综合两个数据源)
    ├── ☁️ 统计云控名单贡献的目标数量
    ├── 🏷️ 在输出中标识云控黑名单目标
    └── 📋 显示云控系统发现的额外黑名单目标
    ↓
🧠 琉克审判决策 (ryuk_judgment)
    ├── 🔍 检查每个识别结果是否在死亡笔记上 (本地+云控)
    ├── 📊 收集所有黑名单目标信息 (综合两个数据源)
    ├── 🍎 根据黑名单目标数量消费苹果 (每个目标1个苹果)
    ├── 😴 调整琉克的厌倦值
    └── 🎯 生成审判决策 (Execute/Skip)
    ↓
⚰️ 执行死神审判 (execute_shinigami_judgment)
    ├── 🚨 有黑名单目标 → 执行灵魂收割仪式
    │   ├── 🔮 启动异步灵魂收割仪式
    │   ├── ⚰️ 并行收割灵魂 (666ms延迟)
    │   ├── ⚰️ 并行收割灵魂 (666ms延迟)
    │   ├── 📖 死亡笔记记录每次收割操作
    │   └── 😈 琉克发表审判感言
    └── ✅ 无黑名单目标 → 琉克选择旁观
    ↓
📊 显示最终审判结果
    ├── 💀 成功收割的灵魂列表
    ├── 💨 逃脱的灵魂及原因
    ├── 📈 被审判的目标总数
    └── 🍎 琉克的苹果消费情况
    ↓
📓 死亡笔记系统运行结束
👁️‍🗨️ 死神之眼已关闭
```

### 🌟 异步并行技术特性

#### 🔍 死神之眼系统
- **⚡ Tokio异步运行时**: 并行执行所有识别器
- **⏰ 超时机制**: 确保单个识别器不会阻塞整体流程
- **🔧 trait抽象**: 支持动态识别器注册和扩展
- **💪 错误隔离**: 单个识别器失败不影响其他识别器的执行
- **🛡️ 内存安全**: 实现线程安全的共享访问
- **🎭 多态支持**: 统一处理不同类型的识别结果

#### ☁️ 云控系统
- **🔀 异步数据获取**: 使用 `async/await` 模式异步获取云端数据
- **📂 智能缓存策略**: TTL机制结合异步I/O实现高效缓存
- **🌐 HTTP客户端池**: 复用连接，提升网络请求性能
- **🛡️ 异步错误处理**: 网络异常时自动降级，保证系统稳定性
- **🔄 后台数据刷新**: 支持定时异步刷新云控数据
- **🚀 Arc<RwLock>**: 多线程安全的读写锁，支持高并发访问

#### ⚙️ 琉克智能特性
- **🍎 苹果计数系统**: 实现线程安全的苹果计数，每发现1个黑名单目标消费1个苹果
- **😴 动态厌倦机制**: 基于发现结果调整厌倦值，影响琉克的行为表现
- **😈 性格模拟**: 根据发现数量和厌倦值生成不同的琉克对话
- **⚰️ 异步收割**: 模拟666ms的死神收割仪式延迟
- **📖 审判记录**: 每次灵魂收割都会在死亡笔记上留下记录

## 🔧 配置管理系统

### 🎆 黑名单配置管理

项目实现了基于 `build.rs` 构建脚本 + TOML 配置的黑名单管理系统，实现了**开发环境中读取配置，编译时嵌入到最终产物**的高效机制。

#### 📄 黑名单配置文件

- **`config/blacklist_config.toml`** - 黑名单配置文件（开发时编辑）
- **`config/examples/blacklist_config.example.toml`** - 黑名单配置模板文件
- **`build.rs`** - 构建脚本（读取配置并生成代码）
- **`target/debug/build/death_note-*/out/blacklist_data.rs`** - 自动生成的黑名单数据（请勿手动修改）
- **`src/blacklist/*.rs`** - 黑名单模块（使用 `include!` 宏引入生成的数据）

### ⚙️ 技术实现

```toml
# blacklist_config.toml 示例
[coolapk]
users = [
    "1234567",  # 被琉克记录的酷安用户1
    "9999999",  # 被琉克记录的酷安用户2
    "9876543",  # 新增的酷安用户（演示配置更新）
]

[qq]
users = [
    "123456789",
    "987654321", 
    "555555555",
    "111111111",
]

[telegram]
users = [
    "100000000",
    "200000000",
    "300000000",
]

[meta]
version = "1.0"
description = "死亡笔记黑名单配置文件"
last_updated = "2025-09-14"
```

### ☁️ 云控配置管理

项目还实现了**云控系统配置管理**，支持动态获取云端黑名单数据，与本地编译数据完全分离。

#### 📄 云控配置文件

- **config/cloud_config.toml** - 云控系统配置文件（开发时编辑）
- **config/examples/cloud_config.example.toml** - 云控配置模板文件
- **`target/debug/build/death_note-*/out/cloud_config.rs`** - 自动生成的云控配置代码
- **`src/cloud_control/embedded_config.rs`** - 云控配置模块（使用 `include!` 宏引入生成的配置）

#### ⚙️ 云控配置示例

```toml
# cloud_config.toml 示例
[enabled]
enabled = true

[repository]
url = "https://gitee.com/your-username/death-note-cloud"
branch = "main"
data_file = "blacklist.toml"
access_token = "your_access_token_here"  # 可选

[cache]
cache_dir = ".cache/cloud_control"
cache_file = "cloud_data.json"
ttl_seconds = 3600  # 缓存1小时

[update]
check_interval_seconds = 300  # 每5分钟检查更新
timeout_seconds = 30
retry_count = 3
```

#### 🔀 数据分离机制

- **本地编译名单**：从 `blacklist_config.toml` 编译时嵌入，零运行时开销
- **云控动态名单**：从远程仓库运行时获取，支持动态更新
- **查询逻辑**：系统会同时检查两个数据源，任一匹配即认定为目标
- **互不干扰**：两套数据完全独立，云控系统故障不影响本地功能

### 🚀 优势特性

#### 🏠 本地配置系统
1. **📦 编译时嵌入**：黑名单数据在构建时就编译到二进制文件中，生产环境无需配置文件
2. **⚡ 零运行时开销**：静态常量，无动态加载成本
3. **🛠️ 便于管理**：开发环境中使用清晰的 TOML 配置文件
4. **🔄 自动重构建**：配置文件改变时 Cargo 会自动重新运行构建脚本
5. **🔒 类型安全**：构建时验证配置格式
6. **🎆 完全兼容**：与现有的 `build_android.py` Android 构建脚本完全兼容

#### ☁️ 云控配置系统
1. **🌐 动态更新**：支持运行时从远程仓库获取最新黑名单数据
2. **📂 智能缓存**：本地缓存机制，离线时使用缓存数据，减少网络请求
3. **🛡️ 容错性强**：网络异常时自动降级，不影响程序正常运行
4. **🔀 数据分离**：与本地编译数据完全分离，确保互不干扰
5. **📊 状态监控**：实时显示云控系统状态和数据统计信息
6. **⚙️ 灵活配置**：支持自定义更新间隔、重试次数、缓存策略等

## 🎭 设计理念

本项目采用拟人化的设计理念，将技术系统包装成动漫角色，使得：
- **用户体验**: 更具趣味性和故事性的交互体验
- **系统理解**: 通过动漫设定降低复杂异步系统的理解门槛
- **扩展性**: 新功能可以轻松对应新的死神角色和能力
- **维护性**: 清晰的模块划分和职责分离，易于代码维护
